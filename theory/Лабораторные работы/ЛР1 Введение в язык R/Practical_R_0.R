# ==============================================================================
#  Основные структуры данных и функции в R (Часть 1)
# ==============================================================================

# ------------------------------------------------------------------------------
# 1. Присваивание значений
# ------------------------------------------------------------------------------

# Используем '<-' для присваивания (предпочтительный стиль)
x <- 2
# Можно использовать '=', но '<-' более распространен и читаем
x2 = 2

# Векторы: основной тип данных для хранения последовательности значений
# индекс вектора начинается с 1-цы
x3 <- c(1, 2, 3, 4, 5)
x3  # Выводим содержимое вектора x3

# ------------------------------------------------------------------------------
# 2. Вывод информации
# ------------------------------------------------------------------------------

# Функция print() для вывода объектов с форматированием
hello <- "Hello, World!"
print(hello)  # Выведет: [1] "Hello, World!"
print(paste("The value of x is:", x)) # Выведет: [1] "The value of x is: 2"
print(x3)     # Выведет: [1] 1 2 3 4 5

# Функция cat() (concatenate) для вывода текста собранного из разных переменных
cat(1:3, sep = '\n') # Выведет: 1 2 3 с новой строки
cat("Hello", "World!")   # Выведет: Hello World! (без новой строки)
cat("Hello", "World!\n")   # Выведет: Hello World! 
cat("The value of x is:", x, "\n") # Выведет: The value of x is: 2
# (с новой строки)

# Внимание: cat() возвращает NULL, а не строку!
c <- cat(hello) # Выведет Hello, World! на консоль
c  # Выведет NULL, так как cat() ничего не возвращает

# ------------------------------------------------------------------------------
# 3. Типы данных
# ------------------------------------------------------------------------------

# Функция class() для определения типа данных объекта (аналог typeof() в Python)
class(hello) # Выведет: "character"
class(c)     # Выведет: "NULL" (потому что cat() возвращает NULL)
class(x)     # Выведет: "numeric"

# print() vs cat(): Разница в оформлении и возвращаемом значении
p <- print(x) # Выведет: [1] 2
p  # Выведет: [1] 2 (print() возвращает значение, которое выводится)

c <- cat(x) # Выведет: 2 на консоль (без [1])
c  # Выведет: NULL

# ------------------------------------------------------------------------------
# 4. Ввод данных с клавиатуры
# ------------------------------------------------------------------------------

# Функция scan() для чтения данных с клавиатуры (завершение ввода: Ctrl+D)
X <- scan()
length(X)    # Длина введенного вектора

# ------------------------------------------------------------------------------
# 5. Преобразование типов и поведение векторов
# ------------------------------------------------------------------------------

# Векторы могут содержать только один тип данных.  R автоматически преобразует
# типы, чтобы все элементы вектора были одного типа.

y <- class(c(1, 2, TRUE)) # TRUE преобразуется в 1 (numeric)
y # [1] "numeric"

y <- c(2, "boo") # 2 преобразуется в "2" (character)
y # [1] "2"   "boo"
class(y) # [1] "character"

# Пример преобразования:
# d <- c(1, 2, "tom", 2+8i, TRUE) # Все преобразуется в character
# class(d)
# typeof(d) # typeof() показывает базовый тип хранения, а class() - класс объекта

# ------------------------------------------------------------------------------
# 6. Форматированный вывод с помощью sprintf()
# ------------------------------------------------------------------------------

# Функция sprintf() позволяет форматировать строки для вывода.

# %s - строка
# %f - число с плавающей точкой
# %i или %d - целое число

sprintf("%s %f  число_с_точкой_и_текст\n", "строка", 7.1) # OK
try(sprintf("%s %i целое_число_и_ошибка\n", "строка", 7.1))
# Выдаст ошибку, т.к. %i ожидает целое число
sprintf("%s %i целое_число_без_ошибки\n", "строка", 7)  # OK

# use a literal % :
sprintf("%.0f%% процент_и_значение", 66.666)

# Разные виды вывода числа pi :
sprintf("%f", pi)      # Полное число pi
sprintf("%.3f", pi)    # Число pi с тремя знаками после запятой
sprintf("%1.0f", pi)    # Минимум 1 символ до запятой, 0 после
sprintf("%5.1f", pi)    # Минимум 5 символов всего, 1 после запятой
sprintf("%05.1f", pi)   # Минимум 5 символов всего, 1 после запятой, заполнить нулями
sprintf("%+f", pi)     # Всегда показывать знак
sprintf("% f", pi)     # Показывать пробел для положительных чисел
sprintf("%-10f", pi)    # Выровнять по левому краю в поле шириной 10
sprintf("%e", pi)     # Экспоненциальная нотация
sprintf("%E", pi)     # Экспоненциальная нотация (E вместо e)
sprintf("%g", pi)     # Наиболее компактная форма
sprintf("%g", 1e6 * pi) # Экспоненциальная
sprintf("%.9g", 1e6 * pi) # фиксированная
sprintf("%G", 1e-6 * pi) # Экспоненциальная с E

# no truncation:
sprintf("%1.f", 101)  # Выведет 101

# re-use one argument three times, show difference between %x and %X
xx <- sprintf("%1$d %1$x %1$X", 0:15)
xx <- matrix(xx, dimnames = list(rep("", 16), "%d%x%X"))
noquote(format(xx, justify = "right"))

# NOT RUN { # Удалены комментарии NOT RUN, т.к. примеры можно запустить
# Platform-dependent bad example from qdapTools 1.0.0:
# may pad with spaces or zeroes.
sprintf("%09s", month.name)
# }
# NOT RUN {
n <- 1:18
sprintf(paste0("e with %2d digits = %.", n, "g"), n, exp(1))
# }

# Using arguments out of order
sprintf("second %2$1.0f, first %1$5.2f, third %3$1.0f", pi, 2, 3)

# Using asterisk for width or precision
sprintf("precision %.*f, width '%*.3f'", 3, pi, 8, pi)

# Asterisk and argument re-use, 'e' example reiterated:
sprintf("e with %1$2d digits = %2$.*1$g", n, exp(1))

# re-cycle arguments
sprintf("%s %d", "test", 1:3)

# ------------------------------------------------------------------------------
# 7. Строки
# ------------------------------------------------------------------------------

s <- "Зачем людям суждено встречать тех, кто становится дорог им? Возможно, всё зависит только от судьбы"
nchar(s)  # Количество символов в строке s
length(s) # Длина вектора s (в данном случае 1, т.к. это один элемент)

s2 <- c(
  "Зачем людям суждено встречать тех, кто становится дорог им?",
  "Возможно, всё зависит только от судьбы"
)
length(s2) # Длина вектора s2 (в данном случае 2)
nchar(s2)  # Вектор с количеством символов в каждой строке

substr(s, 7, 11) # Извлекаем подстроку с 7 по 11 символ

s1 <- "Жить, желая лишь дотянуть до завтрашнего дня,"
s2 <- "недопустимо!"
s1
s2

s <- paste(s1, s2) # Объединяем строки
s

#  Ошибка: Нельзя складывать строки напрямую в R (в отличие от Python)
# s <- s1 + s2 # Вызовет ошибку

strsplit(s, ",") # Разделяем строку s по разделителю ","