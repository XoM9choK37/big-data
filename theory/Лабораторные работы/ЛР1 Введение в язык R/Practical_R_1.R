# ==============================================================================
#  Основные структуры данных и функции в R (Часть 2)
# ==============================================================================

#  В этом разделе рассматриваются основные типы данных в R.

# ------------------------------------------------------------------------------
#  Типы данных в R:
# ------------------------------------------------------------------------------

# numeric (числовой): числа с плавающей точкой. В большинстве случаев R по умолчанию
#   использует numeric для представления числовых данных. Важно помнить, что
#   даже целые числа часто хранятся как numeric, если явно не указано иное.

# integer (целочисленный): целые числа. Используются для экономии памяти и
#   улучшения производительности, если требуется работа только с целыми числами.

# character (символьный/строковый): текстовые данные.

# logical (логический): TRUE или FALSE.

# factor (фактор): категориальные данные.

# ts (временные ряды): для работы с данными, зависящими от времени.

# Matrix (матрица): двумерный массив чисел.

# data.frame (таблица данных): структура для хранения данных в виде таблицы (похожа на таблицу в Excel).
#   data.table (расширение data.frame): более быстрый и функциональный вариант data.frame.

# list (список): упорядоченный набор элементов, которые могут быть разных типов.

# ------------------------------------------------------------------------------
#  Создание векторов различных типов
# ------------------------------------------------------------------------------

i <- integer(10) # Создаем вектор типа integer длиной 10, заполненный нулями.
typeof(i)         # Проверяем тип: "integer"

i <- (10)          # Присваиваем переменной i значение 10 (numeric, а не integer!)
typeof(i)         # Проверяем тип: "double" (numeric в R)

l <- logical(5) # Создаем вектор типа logical длиной 5, заполненный FALSE.
typeof(l)       # Проверяем тип: "logical"

# Справка по функции typeof:
? typeof
help(typeof)


# ------------------------------------------------------------------------------
#  Функция c(...): объединение (конкатенация) элементов в вектор
# ------------------------------------------------------------------------------

c(1, 2, 3)         # Создаем вектор из чисел 1, 2, 3
j <- c(c(1, 2), 3) # Объединяем два вектора (c(1, 2) и 3) в один
length(c(1, 2, 3))  # Определяем длину вектора (в данном случае 3)
rm(j)              # Удаляем переменную j

i <- 5:100       # Создаем последовательность чисел от 5 до 100
i[1]             # Доступ к первому элементу вектора (индексация начинается с 1!)

typeof(j)         # Тип переменной j, если бы она не была удалена
typeof(l)         # Тип переменной l (logical)

# ------------------------------------------------------------------------------
#  Функция seq(from, to, by = d) и seq(from, to, length = n): создание последовательностей
#  [from, to] - диапазон, by = d - шаг, length = n - количество элементов
# ------------------------------------------------------------------------------

i <- seq(from = 0, to = 1, by = 0.1) # Создаем последовательность от 0 до 1 с шагом 0.1
typeof(i)                               # Тип: "double"

seq(0, 1, len = 5)     # Создаем последовательность от 0 до 1, содержащую 5 элементов
seq(2, 20, 2)          # Создаем последовательность от 2 до 20 с шагом 2
c(1:5, 20, 11:15)     # Объединяем несколько последовательностей и чисел в один вектор
c(1:5, seq(10, 20, 2)) # Объединяем последовательность и результат работы seq

# ------------------------------------------------------------------------------
#  Функция rep(x, times): повторение элемента x times раз
# ------------------------------------------------------------------------------

rep(c(TRUE, FALSE), 3) # Повторяем вектор c(TRUE, FALSE) 3 раза

# ------------------------------------------------------------------------------
#  Индексация векторов, выборка элементов по условию
# ------------------------------------------------------------------------------

(10:20)[c(1, 3, 5)]  # Выбираем 1-й, 3-й и 5-й элементы из последовательности 10:20
(10:20)[-c(1, 3, 5)] # Исключаем 1-й, 3-й и 5-й элементы из последовательности 10:20
x <- c(1, 3, 5, 7, 9)  # Создаем вектор x

int_var <- c(1L, 6L, 10L) # Создаем вектор integer (с суффиксом L)
typeof(int_var)           # Тип: "integer"
int_var <- c(1, 6, 10)   # Создаем вектор numeric (без суффикса L)
typeof(int_var)           # Тип: "double"

x1 <- 1:10         # Создаем вектор x1
y <- rep(c(1, 5), 10) # Создаем вектор y с повторением c(1,5)
x1 + 1           # Добавляем 1 к каждому элементу вектора x1
y + 2           # Добавляем 2 к каждому элементу вектора y

x1 + y            # Сложение двух векторов (элементы складываются поэлементно).
#  Если длины векторов не совпадают, R выполняет "переработку" (recycling) меньшего вектора.

# ------------------------------------------------------------------------------
#  Функция sample(x, n, replace = FALSE, prob = NULL): случайная выборка
#  x - вектор, из которого выбираем, n - количество элементов для выборки
#  replace = FALSE - выборка без возвращения (элементы не могут повторяться)
#  replace = TRUE - выборка с возвращением (элементы могут повторяться)
#  prob - вектор вероятностей выбора каждого элемента
# ------------------------------------------------------------------------------

sample(1:20, 5, replace = FALSE) # Выбираем 5 случайных чисел из диапазона 1:20 без повторений
sample(1:3, 5, replace = TRUE)  # Выбираем 5 случайных чисел из диапазона 1:3 с повторениями

x <- sample(c(0, 1), 100, replace = TRUE, prob = c(0.3, 0.7)) # Выбираем 100 раз 0 или 1
#  с вероятностями 0.3 и 0.7 соответственно

#  Внимание: Функция sample() используется для генерации случайных выборок из
#  заданного набора данных.

# ------------------------------------------------------------------------------
#  Индексация данных в матрице
# ------------------------------------------------------------------------------

A <- matrix(1:16, 4, 4) # Создаем матрицу 4x4, заполненную числами от 1 до 16
A                     # Выводим матрицу A
typeof(A)             # Тип: "integer" или "double" (в зависимости от версии R)
class(A)              # Класс: "matrix"

# ------------------------------------------------------------------------------
#  Примеры индексации матрицы:
# ------------------------------------------------------------------------------

A[2, 3]        # Элемент во 2-й строке и 3-м столбце
A[1:3, 2:4]    # Подматрица, состоящая из строк 1-3 и столбцов 2-4

A[1, ]        # Первая строка матрицы
A[1:2, ]      # Первые две строки матрицы
A[, 1:2]      # Первые два столбца матрицы

A[c(1, 3), c(2, 4)] # Выбираем элементы из 1-й и 3-й строк и 2-го и 4-го столбцов

A[-c(1, 3), ]     # Исключаем 1-ю и 3-ю строки из матрицы
A[-c(1, 3), -c(1, 3, 4)] # Исключаем 1-ю и 3-ю строки и 1-й, 3-й и 4-й столбцы
A[-c(1, 3), 2]     # Исключаем 1-ю и 3-ю строки, выбираем только 2-й столбец

dim(A) # Возвращает размерность матрицы (количество строк и столбцов)

# ------------------------------------------------------------------------------
#  Присваивание имен элементам вектора
# ------------------------------------------------------------------------------

#  Имена элементов вектора позволяют обращаться к ним по имени, а не только по индексу.
#  Есть несколько способов присвоить имена элементам вектора:

#  Способ 1: При создании вектора
x <- c(a = 1, b = 2, c = 3)
x

#  Способ 2: После создания вектора с использованием names()
x <- 1:3
names(x) <- c("a", "b", "c")
x

#  Способ 3: Попытка присвоить имя отдельному элементу (не рекомендуется)
x <- 1:3
# names(x)[[1]] <- c("a") #  Это не сработает так, как ожидается.
x

#  Функция setNames() упрощает присваивание имен:
#  Важно: setNames() создает *копию* вектора, а не изменяет исходный.

#  Присвоение одинаковых имен (не рекомендуется, но возможно):
x <- setNames(1:3, c("a", "b", "a"))
x

#  Присвоение уникальных имен (рекомендуется):
x <- setNames(1:3, c("a", "b", "c"))
x

# ------------------------------------------------------------------------------
#  Генерация случайных чисел
# ------------------------------------------------------------------------------

#  R предоставляет функции для генерации случайных чисел из различных распределений.
#  Это полезно для моделирования, симуляций и статистического анализа.

#  rnorm(n, mean, sd) - генерирует n случайных чисел из нормального распределения
#  со средним mean и стандартным отклонением sd.

#  runif(n, min, max) - генерирует n случайных чисел из равномерного распределения
#  на интервале [min, max].

#  rexp(n, rate) - генерирует n случайных чисел из экспоненциального распределения
#  с параметром rate (интенсивность).

x <- rnorm(100, mean = 0, sd = 0.5)
x
hist(x) # График гистограммы для визуализации распределения.
y <- runif(100, min = 0, max = 1)
y
hist(y) # Равномерное распределение
z <- rexp(100, rate = 1)
z
hist(z) # Экспоненциальное распределение

# ------------------------------------------------------------------------------
#  Удаление элементов из вектора
# ------------------------------------------------------------------------------

#  Можно удалять элементы из вектора по индексу или по условию.

a <- (1:10)
a
remove <- c(3, 5, 7) # Индексы элементов для удаления
a <- a[-remove]      # Удаляем элементы с индексами 3, 5, 7
a
a <- a[-c(1, 2)]     # Удаляем первые два элемента
a
a <- a[-length(a)]   # Удаляем последний элемент

#  Важно: Удаление элементов создает *новый* вектор, а не изменяет исходный.

x <- -1:8
x
x[c(1, 3, 4)] # Выбираем элементы с индексами 1, 3, 4
x[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)] # Логический вектор для выбора элементов
#  Важно: Длина логического вектора должна совпадать с длиной вектора, из которого выбираются элементы.

#  Использование логических векторов для фильтрации данных:
#  Операторы сравнения: >, <, ==, !=, >=, <=
#  Логические операторы: &, |, !

x > 5       # Создает логический вектор, TRUE если элемент > 5
sum(x > 5)  # Количество элементов, которые больше 5
sum(x[x > 5]) # Сумма элементов, которые больше 5
sum(x > 5 | x < 3) # Сумма элементов, которые больше 5 ИЛИ меньше 3

#  Важно: Порядок операций: сначала сравнение, затем логические операции.

y <- c(2, 3, 5, 7, 11, 13)
y
y[3]    # Элемент с индексом 3
y[-3]   # Все элементы, кроме элемента с индексом 3

X <- c(5, 4, 11)
y[X]    #  Будет ошибка, так как индекс 11 выходит за границы вектора y. При выходе индекса за границы вернется NA.

# (Возвращает NA, если индекс выходит за границы вектора)

# ------------------------------------------------------------------------------
#  Работа с матрицами
# ------------------------------------------------------------------------------

#  Матрица - это двумерный массив данных.

z.1 <- 1:12 * 5 # Создаем вектор z.1
z.2 <- 1:(12 * 5) # Создаем вектор z.2
typeof(z.1)     # Тип: "double"

#  Преобразование вектора в матрицу:
x <- 1:12
dim(x) <- c(3, 4) # Изменяем размерность вектора x на 3 строки и 4 столбца
x #  Теперь x - матрица
x[2, 3] #  Элемент во 2-й строке и 3-м столбце
print(x[-c(2, 3, 10)]) # Удаляем элементы 2, 3 и 10 (если бы x был вектором)

#  Создание матрицы с использованием matrix():
m <- matrix(1:12,
            nrow = 3,
            ncol = 4,
            byrow = TRUE) # Заполняем матрицу по строкам
m

nrow(m) # Количество строк
ncol(m) # Количество столбцов

#  Поиск индекса элемента по значению:
indexes <- which(m == 8, arr.ind = TRUE) # Находим индексы всех элементов, равных 8
indexes
row <- indexes[1, 1] # Строка первого найденного элемента
col <- indexes[1, 2] # Столбец первого найденного элемента
m[row, col] # Получение значения по строке и столбцу
m[indexes] # Получение значения по координатам

# ------------------------------------------------------------------------------
#  Примеры работы с векторами и условиями
# ------------------------------------------------------------------------------

z <- c(1, 8, 2, 6, 5, 8, 5, 5, 5, 5)
#  Пусть zi - значение i-го элемента вектора z.
#  Необходимо:
#  1) найти log10(zi) для элементов i, исключая элементы i, для которых zi == 8
#  2) найти (zi-1)/2 для элементов i, исключая элементы i, для которых zi == 8
#  3) найти (zi-1)%/%2 для элементов i, исключая элементы i, для которых zi == 8
#  4) найти min() и max() для элементов zi
#  5) исключить из вектора все элементы, для которых zi равно 8 ИЛИ 5

# Решения:

z[z != 8] #  Выбираем все элементы, кроме 8
# z[z = 8] #  ОШИБКА: Некорректный оператор присваивания
z[z == 8] #  Выбираем все элементы, равные 8
z[which(z == 8)] #  Эквивалентно предыдущему, с использованием which()

unique(z) # Уникальные значения в векторе
#  или
z[!duplicated(z)] #  То же самое, с использованием duplicated()
z[duplicated(z)] #  Выбираем повторяющиеся элементы

#  6) Найти индексы элементов, равных 8 или 5
which(z %in% c(5, 8)) #  Используем оператор %in% для проверки вхождения в вектор

which.max(z) # Индекс максимального элемента
which.min(z) # Индекс минимального элемента

# ------------------------------------------------------------------------------
#  Работа с data.frame (таблицами данных)
# ------------------------------------------------------------------------------

#  Создание data.frame:
df <- data.frame(c1 = 1:4, c2 = с(a,b,c), c3 = 5:8)
df

#  Удаление столбца "c2":
df_new <- df[, -which(names(df) %in% c("c2"))]
df_new
df_new1 <- df[, -2] # Удаление столбца по индексу
df_new1

nrow(df_new1) # Количество строк
ncol(df_new1) # Количество столбцов